流程：
1. main函数在tcpepoll.cpp中，首先会根据命令行参数ip和port创建一个TcpServer类实例,同时设置ThreadNum
2. TcpServer构造函数中创建以下对象：
    1. EventLoop,Socket,Channel,InetAddress,一个map管理所有的TcpConnetion连接
    2. 调用threadPool->start(),里面根据ThreadNum和EventLoopThread->startLoop()创建线程数,
        EventLoopThread:
            1. EventLoopThread->startLoop()创建一个新线程,里面在栈上创建一个EventLoop对象
            2. 调用栈上这个loop->loop(),这就是这个线程里面的EventLoop主循环，不会主动停止，栈对象不销毁
    3. 同时会初始化这个Socket，进行listen,bind等系统调用
    4. 给它的Channel设置回调，目前只有readCallback,并调用enableReading，里面还会调用对应的epoll_event的系统调用
    5. 启动当前TcpServer里面的主EventLoop->loop()，监听事件并分发
3. main函数继续，先设置上层的业务回调给TcpServer，然后调用TcpServer.start()开始事件循环
4. TcpServer.start调用它的主事件循环EventLoop.run()，进行处理系统调用epoll_wait()的返回值
5. 每个事件封装成Channel类，然后调用每个Channel的handleEvent()
    1. 读事件：
        1. 调用Channel对应的读事件回调，该回调由TcpServer创建该Channel的时候设立，为TcpServer::handleNewConnection()
        2. 强调：此时是首次连接。该回调首先通过TcpServer类里面的Socet获取该新连接客户端的fd，然后创建该客户端的TcpConnection
        3. 把该TcpConnection加入TcpServer类里面的map，确保引用，同时初始化该TcpConnection的回调函数，来自于main的和close相关的
        4. 调用该TcpServer的threadPool_->getNextLoop()，就是获得ioLoop，把这个EventLoop线程给这个新的TcpConnection
        EventLoop有成员std::vector<std::function<void()>> pendingFuncs_，调用
        ioLoop->queueInLoop([conn]() { conn->connectEstablished(); });把这个函数加入到这个vector里面等待调用
        EventLoop有eventFd成员，用来解决阻塞问题。创建eventloop对应的一个channel,把它注册到当前eventloop类的epoll里面，并初始化它的写回调。它的回调是EventLoop->handleWakeup。这个eventfd和channel存在的意义就是防止在epoll->poll无限阻塞等待新事件，直接导致eventloop->loop无限等待，不能去处理pendingfunctions。
        它的运作是eventloop->queueInLoop如果发现当前eventloop->isInLoopThread是false，就调用eventloop->wakeup。
        这个wakeup里面会给这个eventfd写一个任意的东西(该项目是一个uint64_t)这样就会让epoll->poll的event_wait不再阻塞，就能继续实行，然后就能去执行eventloop->loop的下一步，执行pendingfunctions。达到了不会主动去轮询(之前的暂时方法)，而是外部对pendingfunctions做修改，自动去wakeup执行
        "目前暂时把epoll_wait设置成有timeout的，确保不会EventLoop::loop()不会永远阻塞，以后会加入eventFd功能"
        5. 进入TcpConnection:
            1. 构造函数初始化
            2. 等待它对应的EventLoopthread调用它的pendingFuncs_里面的connectEstablished()，会把读事件的回调函数更新为TcpConnection::handleRead()，把它的channel加入内核epoll红黑树等操作
        6. 上面是首次连接，现在已经连接了，并且再次进入Channel的handleEvent，就会进入更后写回调函数TcpConnection::handleRead()
        7. 通过TcpConnection的Buffer成员和Socket处理信息，同时会处理要关闭的情况
        8. 关闭TcpConnection:
            1. 补充，上面的TcpServer创建该TcpConnection时候会设置closeCallback，也就是TcpServer::removeConnection
            2. 两种情况关闭，1是TcpConnection::handleRead()里面，2是Channel::handleEvent，都会调用这个closeCallback
            3. 关闭流程大概就是会显示的关闭fd，调用epoll_ctl和它DEL参数宏，还有把它从所属的TcpServer里面的map移除。
            最后当TcpConnection的引用次数为0时候，自动销毁所有内存，无内存泄漏
    2. 写事件：
        ...
6. EventLoop::loop()继续，会调用EventLoop::doPendingFunctions()去执行




notes:
main里面tcpServer.start()->eventLoop->run()->
然后eventloop->run()里面获得epoll->loop()里面传进来的epoll_wait的vector<Channel *>

(TcpConnection和TcpServer里面都会调用channel->enableReading(),这里面会调用epoll_ctl，
也就是把channel给epoll_event.data.ptr，所以在epoll->loop()能直接把epoll->events_[i].data.ptr
转成channel *(TcpConnection的设置看下面关于tcpconnection->connectEstablished()))

然后eventloop->run()里面调用每个channel->handleEvent()。

读事件调用channel自己的readCallback_。

对于一个tcpserver，它在构造函数里面会把自己server里面的listenChannel的readCallback
设置成Tcpserver->handleNewConnection()。

所以对于每个tcpserver的listenChannel，会调用自己的回调函数也就是Tcpserver->handleNewConnection()
在这里面，会创建新的tcpconnection，此时会在当前tcpserver设置自己的tcpconnection的4个回调函数
目前tcpconnection里面的connectionCallback来自于main，根据当前tcpconnection的是不是connected打印不同语句
里面的closeCallback则是被tcpserver设置，当这个被call时候，会调用tcpconnection里面的handleclose
同时会在tcpserver里面的关于它的所有tcpconnection的map里面删除这个即将关闭的tcpconnectin
因为tcpconnection都是shared_ptr，然后计数为0就自动全部释放了，包括里面的socket，channel

然后调用tcpconnection->connectEstablished()

每个tcpconnection有它自己的channel，在tcpconnection->connectEstablished()会调用
当前tcpconnection的channel->enableReading()，里面会把调用Epoll->updateChannel(),也就是会把当前channel注册到epoll的红黑树里面
(所以上面的关于把Epoll->loop()的epoll_event数组events_[i].ptr.data转成channel*是合法的)

这个目前的来自于main的业务回调，只根据tcpconnection状态打印不同语句
然后调用tcpconnection里面的成员函数指针connectionCallback，这个函数指针会在tcpserver里面
创建新的tcpconnection时候设置成tcpserver自己的connectionCallback，也就是最终来自于main里面传进来的业务回调函数
该函数参数为const TcpConnectionPtr &conn，因为tcpconnection继承自std::enable_shared_from_this<TcpConnection>
所以在tcpconnection里面调用这个函数时候，传入shared_from_this()


同时在Tcpconnection->connectEstablished()里面还会调用tcpconnection->setReadCallback(),
把自己tcpconnection->channel_里面的底层回调设置成自己类里面的handleRead()函数

那么以后进行Epoll->loop()还是这个channel，但是在EventLoop->run()里面调用channel->handleEvent()
这个handleEvent里面还是会调用channel->readCallback_，但此时对于tcpconnection->Channel,它的这个回调
已经变成了刚刚设置的tcpconnection->handleRead()了






